\hypertarget{delaylama__perform64_8c}{}\section{/\+Users/\+Cloud/\+Documents/\+Max 7/\+Packages/\+D\+A\+O\+C\+D\+\_\+\+Update\+\_\+2016/\+Code/\+Max\+M\+SP Code/examples/\+Projects 2016/delaylama$\sim$ 2 2/delaylama\+\_\+perform64.c File Reference}
\label{delaylama__perform64_8c}\index{/\+Users/\+Cloud/\+Documents/\+Max 7/\+Packages/\+D\+A\+O\+C\+D\+\_\+\+Update\+\_\+2016/\+Code/\+Max\+M\+S\+P Code/examples/\+Projects 2016/delaylama$\sim$ 2 2/delaylama\+\_\+perform64.\+c@{/\+Users/\+Cloud/\+Documents/\+Max 7/\+Packages/\+D\+A\+O\+C\+D\+\_\+\+Update\+\_\+2016/\+Code/\+Max\+M\+S\+P Code/examples/\+Projects 2016/delaylama$\sim$ 2 2/delaylama\+\_\+perform64.\+c}}
{\ttfamily \#include \char`\"{}ext.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}z\+\_\+dsp.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}ext\+\_\+obex.\+h\char`\"{}}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include \char`\"{}mystruct.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}delaylama\+\_\+class.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}delaylama\+\_\+utility.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{delaylama__perform64_8c_a8c1ed473e53e0012fdbba4781012272c}{delaylama\+\_\+perform64}} (\mbox{\hyperlink{mystruct_8h_a09e38f4acb98a28fd6cd51b197468ab1}{t\+\_\+delaylama}} $\ast$x, t\+\_\+object $\ast$dsp64, double $\ast$$\ast$ins, long numins, double $\ast$$\ast$outs, long numouts, long n, long flags, void $\ast$userparam)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{delaylama__perform64_8c_a8c1ed473e53e0012fdbba4781012272c}\label{delaylama__perform64_8c_a8c1ed473e53e0012fdbba4781012272c}} 
\index{delaylama\+\_\+perform64.\+c@{delaylama\+\_\+perform64.\+c}!delaylama\+\_\+perform64@{delaylama\+\_\+perform64}}
\index{delaylama\+\_\+perform64@{delaylama\+\_\+perform64}!delaylama\+\_\+perform64.\+c@{delaylama\+\_\+perform64.\+c}}
\subsubsection{\texorpdfstring{delaylama\+\_\+perform64()}{delaylama\_perform64()}}
{\footnotesize\ttfamily void delaylama\+\_\+perform64 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{mystruct_8h_a09e38f4acb98a28fd6cd51b197468ab1}{t\+\_\+delaylama}} $\ast$}]{x,  }\item[{t\+\_\+object $\ast$}]{dsp64,  }\item[{double $\ast$$\ast$}]{ins,  }\item[{long}]{numins,  }\item[{double $\ast$$\ast$}]{outs,  }\item[{long}]{numouts,  }\item[{long}]{n,  }\item[{long}]{flags,  }\item[{void $\ast$}]{userparam }\end{DoxyParamCaption})}

must be included first first inlet from left is our signal input ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 second inlet from left is our delay time ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 third inlet from left is our feedback factor ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 our external has only one ouptput ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 assigning the needed variables from the object structure into local variables cause it\textquotesingle{}s more efficient to use local variables rather than pull them off of the object structure every single time they are needed!

the address of the beginning of the delay line plus the number of samples in the the delay line multiplied by the size of float.\+So end\+\_\+of\+\_\+memory will point to one slot beyond the last float in the delay line memory

fractional difference used for our simple linear interpolation ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 samp1 \& samp2 are used for linear interpolation and are taken from our delay line ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline


~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
From here on we choose the correct D\+SP configuration based on which inlets are connected and which of them aren\textquotesingle{}t.

Our delay time and feedback inlets accept both floats and signals

the logic of the chosen decision tree is as follows\+:

if (both delay\+\_\+time and feedback are connected)\{...\}

else if (delay\+\_\+time is connected)\{...\}

else if( feedback is connected)\{...\}

else \{...\}

By truncating the actual delay time and subtract the truncated delay time from the actual delay time we get a fraction. We can use this fraction to determine the relative contribution of two samples, the first one at the truncated delay time slot and the second sample will be taken one slot beyond the first delay time slot. But why linear interpolation? well consider the case that we have a delay time of 69 ms. Converting milliseconds to samples we get 69 $\ast$ 44100 / 1000 = 3042.\+9 samples! we can store this sample at delay 3042 or 3043 but not between these two points! so using linear interpolation instead of just rounding gives us a smoother transition. also note that one of the most basic and simplest forms of linear interpolation has been implemented here.

here the first sample is taken for linear interpolation ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 here the second sample is taken for our linear interpolation ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 here the input sample plus feedback is written to the current write location on the delay line

the output sample is written to the output signal vector \& the write pointer is incremented

while there\textquotesingle{}s still some input coming ~\newline
~\newline
~\newline
~\newline
~\newline
 if the fractional\+\_\+differenceal delay is less than zero, set it to a default ~\newline
~\newline
~\newline
~\newline
 if the fractional delay goes over the range, bring it back! ~\newline
~\newline
~\newline
 here the first sample is taken for linear interpolation ~\newline
~\newline
 here the second sample is taken for our linear interpolation ~\newline
 since the current value of our write pointer has changed in our perform routine it must be copied back to the object structure.

Definition at line 54 of file delaylama\+\_\+perform64.\+c.

